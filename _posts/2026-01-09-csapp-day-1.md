---
title: CS:APP Chapter 1
layout: post
date: 2026-01-09
media_subpath: /pics/2026-01-09-csapp-chapter-1/
image:
    path: https://csapp.cs.cmu.edu/3e/images/csapp3e-cover.jpg
categories: computer-system
tags: [CSAPP]
---

# Section 1.2
## Compilation System
![Compilation System](compilation-system.png)

Understanding the compilation system is important for optimizing program performace.

### Phases
1. **Preprocessing phase**: The preprocessor (`cpp`) modifies the original C program according to directives that begin with the '#' character (such as `#include <stdio.h>`).
2. **Compilation phase**: The compiler (`cc1`) translates the text file `hello.i` into the text file `hello.s`, which contains an assembly-language program. Assembly language is useful because it provides a common output language for different compilers for different high-level languages.
3. **Assembly phase**: The assembler (`as`) translates `hello.s` into machine-language instructions, packages them in a form known as a relocatable object program, and stores the result in the binary object file `hello.o`.
4. **Linking phase**: The linker (`ld`) handles the merging of the precompiled object file `hello.o` with the `printf` function which is part of the standard C library provided by every C compiler. The result is the `hello` file, which is a binary executable object file (or simply executable) that is ready to be loaded into memory and executed by the system.

### Practice
I'll use my Ubuntu 22.04 virtual machine for many CS:APP experiments.

![Ubuntu](/practice/compilation-system/1.png)

To examine the compilation system, you can use either methods:

A. Use `cpp`, `cc1`, `as`, and `ld` as the book guides.

B. Use `gcc`. It is the **GNU Compiler Collection** with many compilers, so it is more handy and you'll patronize it soon.

Before you begin, you need to check whether you have the tools on your system by typing these:
```bash
# For the first method:
cpp --version
as --version
ld --version

# For the second method:
gcc --version
```

If you miss something, run these commands:
```bash
sudo apt update
sudo apt install build-essential
```

![Tools Check](/practice/compilation-system/2.png)

And write a simple C source code `hello.c` with your favorite editor. I'll use Vim for it.

```c
#include <stdio.h>

int main() {
	printf("Hello, world!\n");
	return 0;
}
```

* Small tips for Ubuntu: Type `ls` on the terminal shows files in the directory. Especially `ls -al` shows all files (including files start with '.') in long listing format. Type `cd /path/to/go` to go to `/path/to/go`.

* Small tips for Vim: Type `vim hello.c` on the terminal. It tries to open `hello.c`, or create the file if it does not exist. Press `i` key, write the source, press `ESC`, and type `:wq`. It will save the source and immediately exit Vim.

![hello.c](/practice/compilation-system/3.png)

#### A. Using separate tools

1) Use the C preprocessor `cpp`. It will include the header file `stdio.h`, recognised in the context of preprocessor directive starting with `#`.

```bash
cpp hello.c > hello.i
```

Options:
* `> hello.i`: Save output to `hello.i`.

![cpp](/practice/compilation-system/4.png)

It will produce `hello.i`. When you open it, you will see `stdio.h` source is included.

![hello.i](/practice/compilation-system/5.png)

![hello.i](/practice/compilation-system/5a.png)

2) Use `cc1` to compile `hello.i`.

To find the directory of the compiler `cc1` from the GCC library, run this command:

```bash
find /usr/lib/gcc -name cc1
# /usr/lib/gcc/x86_64-linux-gnu/11/cc1
```
```bash
/usr/lib/gcc/x86_64-linux-gnu/11/cc1 hello.i -o hello.s -quiet -Og
```

Options:
* `-o hello.s`: Save output to `hello.s`.
* `-quiet`: Hide extra messages.
* `-Og`: Optimize for debugging.

Or you can use `gcc` here.

```bash
gcc -S hello.i -o hello.s -Og
```

Options:
* `-S`: Stop at assembly.
* `-o hello.s`: Save output to `hello.s`.
* `-Og`: Optimize for debugging.

![cc1](/practice/compilation-system/6.png)

![hello.s](/practice/compilation-system/7.png)

It will produce `hello.s`. When you open it, you will see a bunch of instructions in assembly language.

![hello.s](/practice/compilation-system/8.png)

3) Use `as` to aseemble `hello.s`.

```bash
as hello.s -o hello.o
```

Options:
* `-o hello.o`: Save output to `hello.o`.

![as](/practice/compilation-system/9.png)

It will produce `hello.o`. From this phase a binary file is created instead of a text file. Therefore, if you open it with a text editor, you will see lots of unreadable garbled characters. 
But...

![binary](/practice/compilation-system/10.png)

Surprise! You can read it using `objdump`! It is used as a disassembler to view an object file or an executable in assembly form.

```bash
objdump -d hello.o
```

Options:
* `-d hello.o`: Disassemble `hello.o`.

![objdump](/practice/compilation-system/objdump1.png)

4) Use `ld` to link `ld` with library and create the final executable, `hello`.

To find the directory of the codes for linking, run this command:

```bash
find /usr/lib64/ -name ld-linux-x86-64.so.2
find /usr/lib -name crt1.o
find /usr/lib -name crti.o
find /usr/lib -name crtn.o
```

```bash
ld -o hello -dynamic-linker /usr/lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o hello.o /usr/lib/x86_64-linux-gnu/crtn.o -lc
```

Options:
* `-o hello`: Save output to `hello`.
* `-dynamic-linker /lib64/ld-linux-x86-64.so.2`: Use `/usr/lib64/ld-linux-x86-64.so.2` as a dynamic linker.
* `/usr/lib/x86_64-linux-gnu/crt1.o`: **C RunTime startup code** (provides the program entry point). It contains the `_start` function, which sets up argc/argv/environment and eventually calls `__libc_start_main` (which handles more initialization before jumping to `main()`).
* `/usr/lib/x86_64-linux-gnu/crti.o`: **CRT Initialization prologue**. It contains the prologue of the `_init` function (in the `.init` section) and the beginning of the `_fini` function (in the `.fini` section).[^1]
* `hello.o`: The file to link.
* `/usr/lib/x86_64-linux-gnu/crtn.o`: **CRT Initialization epilogue**. It contains the epilogue of the `_init` and `_fini` functions (finishing the `.init` and `.fini` sections started by crti.o).
* `-lc` Link with `libc` (standard C library). We bring the `printf` definition from the library. It will find the symbolic link `libc.so.6` which links to the actual file `libc-x.xx-so`.

The kernel loads the dynamic linker (`/lib64/ld-linux-x86-64.so.2`).
The dynamic linker then loads shared libraries[^2] (such as `libc.so.6`) and resolves symbols at runtime.
(Note: The `crt1.o`, `crti.o`, and `crtn.o` files are **statically linked** into the executable during the linking phase — they become part of `hello` itself.)

Or simply use `gcc`!

```bash
gcc hello.o -o hello
```

Option:
* `-o hello`: Save output to `hello`.

![ld](/practice/compilation-system/12.png)

It will produce `hello`. It is a binary executable, so you can see the instructions with `objdump` or execute the program.

![binary](/practice/compilation-system/13.png)

```bash
objdump -d hello
```

![objdump](/practice/compilation-system/objdump2.png)

```bash
./hello
```

![hello](/practice/compilation-system/14.png)

#### B. Using GCC

As I said above, GCC is **GNU Compiler Collection**. That means we can simplify all phases with just one line!

```bash
gcc hello.c -o hello
```

You can also see verbose (what GCC internally does) with `-v` option.

```bash
gcc -v hello.c -o hello
```

![gcc](/practice/compilation-system/f1.png)

![verbose](/practice/compilation-system/f2.png)

# Notes
[^1]: The `.init` section contains executable code that runs **before** `main()` to initialize the process (e.g., calling global constructors in C++). The `.fini` section contains executable code that runs **after** `main()` returns (or on normal exit) for cleanup (e.g., calling global destructors).
[^2]: A **shared library** (.so file on Linux) is a library of executable code that can be loaded into memory and used by **multiple programs** (processes) at the same time. For example, `libc.so.6` contains `printf()` and is used by Firefox, Chrome, your `hello` program - almost everything! It saves memory because all processes map the **same physical RAM pages** for the read-only code part. (Note: Windows uses **DLL** files for the same idea. On Linux, we use **.so** files — "Shared Object". The **SONAME** is a special field inside the .so file that acts as its official name, e.g., `libc.so.6`.)